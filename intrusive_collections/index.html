<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `intrusive_collections` crate."><meta name="keywords" content="rust, rustlang, rust-lang, intrusive_collections"><title>intrusive_collections - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../intrusive_collections/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate intrusive_collections</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all intrusive_collections's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'intrusive_collections', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/intrusive_collections/lib.rs.html#9-316' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>intrusive_collections</a></span></h1><div class='docblock'><p>Intrusive collections for Rust.</p>
<p>This library provides a set of high-performance intrusive collections which
can offer better performance and more flexibility than standard collections.</p>
<p>The main difference between an intrusive collection and a normal one is that
while normal collections allocate memory behind your back to keep track of a
set of <em>values</em>, intrusive collections never allocate memory themselves and
instead keep track of a set of <em>objects</em>. Such collections are called
intrusive because they requires explicit support in objects to allow them to
be inserted into a collection.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::<span class="ident">intrusive_adapter</span>;
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">LinkedList</span>, <span class="ident">LinkedListLink</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">cell</span>::<span class="ident">Cell</span>;

<span class="comment">// A simple struct containing an instrusive link and a value</span>
<span class="kw">struct</span> <span class="ident">Test</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>,
    <span class="ident">value</span>: <span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
}

<span class="comment">// The adapter describes how an object can be inserted into an intrusive</span>
<span class="comment">// collection. This is automatically generated using a macro.</span>
<span class="macro">intrusive_adapter</span><span class="macro">!</span>(<span class="ident">TestAdapter</span> <span class="op">=</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Test</span><span class="op">&gt;</span>: <span class="ident">Test</span> { <span class="ident">link</span>: <span class="ident">LinkedListLink</span> });

<span class="comment">// Create a list and some objects</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">list</span> <span class="op">=</span> <span class="ident">LinkedList</span>::<span class="ident">new</span>(<span class="ident">TestAdapter</span>::<span class="ident">new</span>());
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">Test</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">1</span>),
});
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">Test</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">2</span>),
});
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">Test</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">3</span>),
});

<span class="comment">// Insert the objects at the front of the list</span>
<span class="ident">list</span>.<span class="ident">push_front</span>(<span class="ident">a</span>);
<span class="ident">list</span>.<span class="ident">push_front</span>(<span class="ident">b</span>);
<span class="ident">list</span>.<span class="ident">push_front</span>(<span class="ident">c</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">list</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>(), [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);

<span class="comment">// At this point, the objects are owned by the list, and we can modify</span>
<span class="comment">// them through the list.</span>
<span class="ident">list</span>.<span class="ident">front</span>().<span class="ident">get</span>().<span class="ident">unwrap</span>().<span class="ident">value</span>.<span class="ident">set</span>(<span class="number">4</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">list</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>(), [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]);

<span class="comment">// Removing an object from an instrusive collection gives us back the</span>
<span class="comment">// Box&lt;Test&gt; that we originally inserted into it.</span>
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">list</span>.<span class="ident">pop_front</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">value</span>.<span class="ident">get</span>(), <span class="number">4</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">list</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>(), [<span class="number">2</span>, <span class="number">1</span>]);

<span class="comment">// Dropping the collection will automatically free b and c by</span>
<span class="comment">// transforming them back into Box&lt;Test&gt; and dropping them.</span>
<span class="ident">drop</span>(<span class="ident">list</span>);</pre></div>
<h1 id="links-and-adapters" class="section-header"><a href="#links-and-adapters">Links and adapters</a></h1>
<p>Intrusive collections track objects through links which are embedded within
the objects themselves. It also allows a single object to be part of
multiple intrusive collections at once by having multiple links in it.</p>
<p>The relationship between an object and a link inside it is described by the
<code>Adapter</code> trait. Intrusive collections use an implementation of this trait
to determine which link in an object should be used by the collection. In
most cases you do not need to write an implementation manually: the
<code>intrusive_adapter!</code> macro will automatically generate the necessary code.</p>
<p>For red-black trees, the adapter must also implement the <code>KeyAdapter</code> trait
which allows a key to be extracted from an object. This key is then used to
keep all elements in the tree in ascending order.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::<span class="ident">intrusive_adapter</span>;
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">SinglyLinkedListLink</span>, <span class="ident">SinglyLinkedList</span>};
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">LinkedListLink</span>, <span class="ident">LinkedList</span>};
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">XorLinkedList</span>, <span class="ident">XorLinkedListLink</span>};
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">RBTreeLink</span>, <span class="ident">RBTree</span>, <span class="ident">KeyAdapter</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">rc</span>::<span class="ident">Rc</span>;

<span class="comment">// This struct can be inside three lists and one tree simultaneously</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Default</span>)]</span>
<span class="kw">struct</span> <span class="ident">Test</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>,
    <span class="ident">link2</span>: <span class="ident">SinglyLinkedListLink</span>,
    <span class="ident">link3</span>: <span class="ident">XorLinkedListLink</span>,
    <span class="ident">link4</span>: <span class="ident">RBTreeLink</span>,
    <span class="ident">value</span>: <span class="ident">i32</span>,
}

<span class="macro">intrusive_adapter</span><span class="macro">!</span>(<span class="ident">MyAdapter</span> <span class="op">=</span> <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Test</span><span class="op">&gt;</span>: <span class="ident">Test</span> { <span class="ident">link</span>: <span class="ident">LinkedListLink</span> });
<span class="macro">intrusive_adapter</span><span class="macro">!</span>(<span class="ident">MyAdapter2</span> <span class="op">=</span> <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Test</span><span class="op">&gt;</span>: <span class="ident">Test</span> { <span class="ident">link2</span>: <span class="ident">SinglyLinkedListLink</span> });
<span class="macro">intrusive_adapter</span><span class="macro">!</span>(<span class="ident">MyAdapter3</span> <span class="op">=</span> <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Test</span><span class="op">&gt;</span>: <span class="ident">Test</span> { <span class="ident">link3</span>: <span class="ident">XorLinkedListLink</span> });
<span class="macro">intrusive_adapter</span><span class="macro">!</span>(<span class="ident">MyAdapter4</span> <span class="op">=</span> <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Test</span><span class="op">&gt;</span>: <span class="ident">Test</span> { <span class="ident">link4</span>: <span class="ident">RBTreeLink</span> });
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">KeyAdapter</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">MyAdapter4</span> {
    <span class="kw">type</span> <span class="ident">Key</span> <span class="op">=</span> <span class="ident">i32</span>;
    <span class="kw">fn</span> <span class="ident">get_key</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Test</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">i32</span> { <span class="ident">x</span>.<span class="ident">value</span> }
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">LinkedList</span>::<span class="ident">new</span>(<span class="ident">MyAdapter</span>::<span class="ident">new</span>());
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">SinglyLinkedList</span>::<span class="ident">new</span>(<span class="ident">MyAdapter2</span>::<span class="ident">new</span>());
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">XorLinkedList</span>::<span class="ident">new</span>(<span class="ident">MyAdapter3</span>::<span class="ident">new</span>());
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">d</span> <span class="op">=</span> <span class="ident">RBTree</span>::<span class="ident">new</span>(<span class="ident">MyAdapter4</span>::<span class="ident">new</span>());

<span class="kw">let</span> <span class="ident">test</span> <span class="op">=</span> <span class="ident">Rc</span>::<span class="ident">new</span>(<span class="ident">Test</span>::<span class="ident">default</span>());
<span class="ident">a</span>.<span class="ident">push_front</span>(<span class="ident">test</span>.<span class="ident">clone</span>());
<span class="ident">b</span>.<span class="ident">push_front</span>(<span class="ident">test</span>.<span class="ident">clone</span>());
<span class="ident">c</span>.<span class="ident">push_front</span>(<span class="ident">test</span>.<span class="ident">clone</span>());
<span class="ident">d</span>.<span class="ident">insert</span>(<span class="ident">test</span>);</pre></div>
<h1 id="cursors" class="section-header"><a href="#cursors">Cursors</a></h1>
<p>Intrusive collections are manipulated using cursors. A cursor is similar to
an iterator, except that it can freely seek back-and-forth, and can safely
mutate the list during iteration. This is similar to how a C++ iterator
works.</p>
<p>A cursor views an intrusive collection as a circular list, with a special
null object between the last and first elements of the collection. A cursor
will either point to a valid object in the collection or to this special
null object.</p>
<p>Cursors come in two forms: <code>Cursor</code> and <code>CursorMut</code>. A <code>Cursor</code> gives a
read-only view of a collection, but you are allowed to use multiple <code>Cursor</code>
objects simultaneously on the same collection. On the other hand,
<code>CursorMut</code> can be used to mutate the collection, but you may only use one
of them at a time.</p>
<p>Cursors are a very powerful abstraction since they allow a collection to be
mutated safely while it is being iterated on. For example, here is a
function which removes all values within a given range from a <code>RBTree</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::<span class="ident">intrusive_adapter</span>;
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">RBTreeLink</span>, <span class="ident">RBTree</span>, <span class="ident">KeyAdapter</span>, <span class="ident">Bound</span>};

<span class="kw">struct</span> <span class="ident">Element</span> {
    <span class="ident">link</span>: <span class="ident">RBTreeLink</span>,
    <span class="ident">value</span>: <span class="ident">i32</span>,
}

<span class="macro">intrusive_adapter</span><span class="macro">!</span>(<span class="ident">ElementAdapter</span> <span class="op">=</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Element</span><span class="op">&gt;</span>: <span class="ident">Element</span> { <span class="ident">link</span>: <span class="ident">RBTreeLink</span> });
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">KeyAdapter</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">ElementAdapter</span> {
    <span class="kw">type</span> <span class="ident">Key</span> <span class="op">=</span> <span class="ident">i32</span>;
    <span class="kw">fn</span> <span class="ident">get_key</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">e</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Element</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">i32</span> { <span class="ident">e</span>.<span class="ident">value</span> }
}

<span class="kw">fn</span> <span class="ident">remove_range</span>(<span class="ident">tree</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">RBTree</span><span class="op">&lt;</span><span class="ident">ElementAdapter</span><span class="op">&gt;</span>, <span class="ident">min</span>: <span class="ident">i32</span>, <span class="ident">max</span>: <span class="ident">i32</span>) {
    <span class="comment">// Find the first element which is greater than or equal to min</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cursor</span> <span class="op">=</span> <span class="ident">tree</span>.<span class="ident">lower_bound_mut</span>(<span class="ident">Bound</span>::<span class="ident">Included</span>(<span class="kw-2">&amp;</span><span class="ident">min</span>));

    <span class="comment">// Iterate over all elements in the range [min, max]</span>
    <span class="kw">while</span> <span class="ident">cursor</span>.<span class="ident">get</span>().<span class="ident">map_or</span>(<span class="bool-val">false</span>, <span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="ident">e</span>.<span class="ident">value</span> <span class="op">&lt;</span><span class="op">=</span> <span class="ident">max</span>) {
        <span class="comment">// CursorMut::remove will return a Some(&lt;Box&lt;Element&gt;), which we</span>
        <span class="comment">// simply drop here. This will also advance the cursor to the next</span>
        <span class="comment">// element.</span>
        <span class="ident">cursor</span>.<span class="ident">remove</span>();
    }
}</pre></div>
<h1 id="scoped-collections" class="section-header"><a href="#scoped-collections">Scoped collections</a></h1>
<p>Instead of taking ownership of objects inserted into them, intrusive
collections can also work with borrowed values. This works by using
lifetimes and the borrow checker to ensure that any objects inserted into an
intrusive collection will outlive the collection itself.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::<span class="ident">intrusive_adapter</span>;
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">LinkedListLink</span>, <span class="ident">LinkedList</span>};
<span class="kw">use</span> <span class="ident">typed_arena</span>::<span class="ident">Arena</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">cell</span>::<span class="ident">Cell</span>;

<span class="kw">struct</span> <span class="ident">Value</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>,
    <span class="ident">value</span>: <span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
}

<span class="comment">// Note that we use a plain reference as the pointer type for the collection.</span>
<span class="macro">intrusive_adapter</span><span class="macro">!</span>(<span class="ident">ValueAdapter</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Value</span>: <span class="ident">Value</span> { <span class="ident">link</span>: <span class="ident">LinkedListLink</span> });

<span class="comment">// Create an arena and a list. Note that since stack objects are dropped in</span>
<span class="comment">// reverse order, the Arena must be created before the LinkedList. This</span>
<span class="comment">// ensures that the list is dropped before the values are freed by the</span>
<span class="comment">// arena. This is enforced by the Rust lifetime system.</span>
<span class="kw">let</span> <span class="ident">arena</span> <span class="op">=</span> <span class="ident">Arena</span>::<span class="ident">new</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">list</span> <span class="op">=</span> <span class="ident">LinkedList</span>::<span class="ident">new</span>(<span class="ident">ValueAdapter</span>::<span class="ident">new</span>());

<span class="comment">// We can now insert values allocated from the arena into the linked list</span>
<span class="ident">list</span>.<span class="ident">push_back</span>(<span class="ident">arena</span>.<span class="ident">alloc</span>(<span class="ident">Value</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">1</span>),
}));
<span class="ident">list</span>.<span class="ident">push_back</span>(<span class="ident">arena</span>.<span class="ident">alloc</span>(<span class="ident">Value</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">2</span>),
}));
<span class="ident">list</span>.<span class="ident">push_back</span>(<span class="ident">arena</span>.<span class="ident">alloc</span>(<span class="ident">Value</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">3</span>),
}));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">list</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>(), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);

<span class="comment">// We can also insert stack allocated values into an intrusive list.</span>
<span class="comment">// Again, the values must outlive the LinkedList.</span>
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Value</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">4</span>),
};
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">Value</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">5</span>),
};
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">Value</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">6</span>),
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">list2</span> <span class="op">=</span> <span class="ident">LinkedList</span>::<span class="ident">new</span>(<span class="ident">ValueAdapter</span>::<span class="ident">new</span>());
<span class="ident">list2</span>.<span class="ident">push_back</span>(<span class="kw-2">&amp;</span><span class="ident">a</span>);
<span class="ident">list2</span>.<span class="ident">push_back</span>(<span class="kw-2">&amp;</span><span class="ident">b</span>);
<span class="ident">list2</span>.<span class="ident">push_back</span>(<span class="kw-2">&amp;</span><span class="ident">c</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">list2</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>(), [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);

<span class="comment">// Since these are shared references, any changes in the values are reflected in</span>
<span class="comment">// the list.</span>
<span class="ident">a</span>.<span class="ident">value</span>.<span class="ident">set</span>(<span class="number">7</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">list2</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>(), [<span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>]);</pre></div>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>While it is possible to use intrusive collections without any unsafe code,
this crate also exposes a few unsafe features.</p>
<p>The <code>cursor_from_ptr</code> and <code>cursor_mut_from_ptr</code> allow you to create a
cursor pointing to a specific element in the collection from a pointer to
that element. This is unsafe because it assumes that the objected pointed to
is currently inserted in the collection.</p>
<p>The <code>UnsafeRef</code> type acts like <code>Rc</code>, except without the reference count.
Instead, you are responsible for keeping track of the number of active
references to an object and for freeing it once the last reference is
dropped. The advantage of <code>UnsafeRef</code> over <code>Rc</code> is that it reduces the size
of the allocation by two <code>usize</code> and avoids the overhead of maintaining
reference counts.</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use crate::linked_list::<a class="struct" href="../intrusive_collections/linked_list/struct.Link.html" title="struct intrusive_collections::linked_list::Link">Link</a> as LinkedListLink;</code></td></tr><tr><td><code>pub use crate::linked_list::<a class="struct" href="../intrusive_collections/linked_list/struct.LinkedList.html" title="struct intrusive_collections::linked_list::LinkedList">LinkedList</a>;</code></td></tr><tr><td><code>pub use crate::rbtree::<a class="struct" href="../intrusive_collections/rbtree/struct.Link.html" title="struct intrusive_collections::rbtree::Link">Link</a> as RBTreeLink;</code></td></tr><tr><td><code>pub use crate::rbtree::<a class="struct" href="../intrusive_collections/rbtree/struct.RBTree.html" title="struct intrusive_collections::rbtree::RBTree">RBTree</a>;</code></td></tr><tr><td><code>pub use crate::singly_linked_list::<a class="struct" href="../intrusive_collections/singly_linked_list/struct.Link.html" title="struct intrusive_collections::singly_linked_list::Link">Link</a> as SinglyLinkedListLink;</code></td></tr><tr><td><code>pub use crate::singly_linked_list::<a class="struct" href="../intrusive_collections/singly_linked_list/struct.SinglyLinkedList.html" title="struct intrusive_collections::singly_linked_list::SinglyLinkedList">SinglyLinkedList</a>;</code></td></tr><tr><td><code>pub use crate::xor_linked_list::<a class="struct" href="../intrusive_collections/xor_linked_list/struct.Link.html" title="struct intrusive_collections::xor_linked_list::Link">Link</a> as XorLinkedListLink;</code></td></tr><tr><td><code>pub use crate::xor_linked_list::<a class="struct" href="../intrusive_collections/xor_linked_list/struct.XorLinkedList.html" title="struct intrusive_collections::xor_linked_list::XorLinkedList">XorLinkedList</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="linked_list/index.html" title='intrusive_collections::linked_list mod'>linked_list</a></td><td class='docblock-short'><p>Intrusive doubly-linked list.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="rbtree/index.html" title='intrusive_collections::rbtree mod'>rbtree</a></td><td class='docblock-short'><p>Intrusive red-black tree.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="singly_linked_list/index.html" title='intrusive_collections::singly_linked_list mod'>singly_linked_list</a></td><td class='docblock-short'><p>Intrusive singly-linked list.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="xor_linked_list/index.html" title='intrusive_collections::xor_linked_list mod'>xor_linked_list</a></td><td class='docblock-short'><p>Intrusive xor doubly-linked list which uses less memory than a regular doubly linked list.</p>
</td></tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.container_of.html" title='intrusive_collections::container_of macro'>container_of</a></td><td class='docblock-short'><p>Unsafe macro to get a raw pointer to an outer object from a pointer to one
of its fields.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.intrusive_adapter.html" title='intrusive_collections::intrusive_adapter macro'>intrusive_adapter</a></td><td class='docblock-short'><p>Macro to generate an implementation of <code>Adapter</code> for a given set of types.
In particular this will automatically generate implementations of the
<code>get_value</code> and <code>get_link</code> methods for a given named field in a struct.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.offset_of.html" title='intrusive_collections::offset_of macro'>offset_of</a></td><td class='docblock-short'><p>Calculates the offset of the specified field from the start of the struct.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.DefaultPointerOps.html" title='intrusive_collections::DefaultPointerOps struct'>DefaultPointerOps</a></td><td class='docblock-short'><p>The <code>PointerOps</code> type used by an <code>Adapter</code> generated by <code>intrusive_adapter!</code>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.UnsafeRef.html" title='intrusive_collections::UnsafeRef struct'>UnsafeRef</a></td><td class='docblock-short'><p>Unchecked shared pointer</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.Bound.html" title='intrusive_collections::Bound enum'>Bound</a></td><td class='docblock-short'><p>An endpoint of a range of keys.</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.Adapter.html" title='intrusive_collections::Adapter trait'>Adapter</a></td><td class='docblock-short'><p>Trait for a adapter which allows a type to be inserted into an intrusive
collection.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.DefaultLinkOps.html" title='intrusive_collections::DefaultLinkOps trait'>DefaultLinkOps</a></td><td class='docblock-short'><p>The default implementation of <code>LinkOps</code> associated with a link type.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.KeyAdapter.html" title='intrusive_collections::KeyAdapter trait'>KeyAdapter</a></td><td class='docblock-short'><p>Extension of the <code>Adapter</code> trait to provide a way of extracting a key from
an object. This key can then be used as an index in certain intrusive
collections (currently only <code>RBTree</code> uses this).</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.LinkOps.html" title='intrusive_collections::LinkOps trait'>LinkOps</a></td><td class='docblock-short'><p>Base trait for link operations.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.PointerOps.html" title='intrusive_collections::PointerOps trait'>PointerOps</a></td><td class='docblock-short'><p>Trait for pointer conversion operations.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "intrusive_collections";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>